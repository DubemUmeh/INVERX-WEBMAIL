import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
  Logger,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AttachmentsRepository } from './attachments.repository.js';
import { StorageService } from './storage.service.js';
import { InitiateUploadDto, FinalizeUploadDto } from './dto/index.js';

// Allowed MIME types for attachments
const DEFAULT_ALLOWED_MIME_TYPES = [
  // Documents
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.ms-powerpoint',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  'text/plain',
  'text/csv',
  // Images
  'image/jpeg',
  'image/png',
  'image/gif',
  'image/webp',
  'image/svg+xml',
  // Archives
  'application/zip',
  'application/x-rar-compressed',
  'application/x-7z-compressed',
  // Other
  'application/json',
  'application/xml',
];

// Default max file size: 25MB
const DEFAULT_MAX_FILE_SIZE = 25 * 1024 * 1024;

@Injectable()
export class AttachmentsService {
  private readonly logger = new Logger(AttachmentsService.name);
  private readonly maxFileSize: number;
  private readonly allowedMimeTypes: string[];

  constructor(
    private attachmentsRepository: AttachmentsRepository,
    private storageService: StorageService,
    private configService: ConfigService,
  ) {
    this.maxFileSize = this.configService.get<number>(
      'ATTACHMENT_MAX_SIZE',
      DEFAULT_MAX_FILE_SIZE,
    );
    this.allowedMimeTypes = this.configService.get<string[]>(
      'ATTACHMENT_ALLOWED_TYPES',
      DEFAULT_ALLOWED_MIME_TYPES,
    );
  }

  /**
   * Generate storage key following the convention:
   * accounts/{accountId}/messages/{messageId}/attachments/{attachmentId}/{filename}
   */
  private generateStorageKey(
    accountId: string,
    messageId: string,
    attachmentId: string,
    filename: string,
  ): string {
    // Sanitize filename to prevent path traversal
    const safeFilename = filename.replace(/[^a-zA-Z0-9._-]/g, '_');
    return `accounts/${accountId}/messages/${messageId}/attachments/${attachmentId}/${safeFilename}`;
  }

  /**
   * Step 1: Client initiates upload
   * - Validates request
   * - Creates pending attachment record
   * - Generates signed upload URL
   */
  async initiateUpload(accountId: string, dto: InitiateUploadDto) {
    // Validate file size
    if (dto.sizeBytes > this.maxFileSize) {
      throw new BadRequestException(
        `File size exceeds maximum allowed size of ${this.maxFileSize / 1024 / 1024}MB`,
      );
    }

    // Validate MIME type
    if (!this.allowedMimeTypes.includes(dto.contentType)) {
      throw new BadRequestException(
        `File type '${dto.contentType}' is not allowed`,
      );
    }

    // Generate a temporary attachment ID for the storage key
    // The actual ID will be generated by the database
    const tempId = crypto.randomUUID();

    // Generate storage key
    const storageKey = this.generateStorageKey(
      accountId,
      dto.messageId,
      tempId,
      dto.filename,
    );

    // Create pending attachment record
    const attachment = await this.attachmentsRepository.create({
      messageId: dto.messageId,
      accountId,
      filename: dto.filename,
      contentType: dto.contentType,
      sizeBytes: dto.sizeBytes,
      storageKey,
      contentId: dto.contentId,
    });

    // Generate signed upload URL (short TTL: 2 minutes)
    const signedUrl = await this.storageService.createSignedUploadUrl(
      storageKey,
      120,
    );

    this.logger.log(
      `Initiated upload for attachment ${attachment.id} (${dto.filename})`,
    );

    return {
      attachmentId: attachment.id,
      uploadUrl: signedUrl.url,
      expiresAt: signedUrl.expiresAt,
      storageKey,
    };
  }

  /**
   * Step 2: Client finalizes upload after uploading to Supabase
   * - Verifies file exists in storage
   * - Optionally validates checksum
   * - Updates attachment status to ready
   */
  async finalizeUpload(
    accountId: string,
    attachmentId: string,
    dto?: FinalizeUploadDto,
  ) {
    // Find attachment with ownership check
    const attachment = await this.attachmentsRepository.findByAccountId(
      accountId,
      attachmentId,
    );

    if (!attachment) {
      throw new NotFoundException('Attachment not found');
    }

    if (attachment.status !== 'pending') {
      throw new BadRequestException(
        `Attachment is already ${attachment.status}`,
      );
    }

    // Verify file exists in Supabase
    const exists = await this.storageService.fileExists(attachment.storageKey);
    if (!exists) {
      this.logger.warn(
        `Finalize failed: file not found in storage for ${attachmentId}`,
      );
      throw new BadRequestException(
        'File upload not completed. Please upload the file first.',
      );
    }

    // Optional: Verify file metadata
    const metadata = await this.storageService.getFileMetadata(
      attachment.storageKey,
    );
    if (metadata && metadata.size !== Number(attachment.sizeBytes)) {
      this.logger.warn(
        `Size mismatch for ${attachmentId}: expected ${attachment.sizeBytes}, got ${metadata.size}`,
      );
      // Don't fail - just log the discrepancy
    }

    // Finalize the attachment
    const finalized = await this.attachmentsRepository.finalize(
      attachmentId,
      dto?.checksum,
    );

    this.logger.log(`Finalized attachment ${attachmentId}`);

    return finalized;
  }

  /**
   * Get attachment with ownership check
   */
  async getAttachment(accountId: string, attachmentId: string) {
    const attachment = await this.attachmentsRepository.findByAccountId(
      accountId,
      attachmentId,
    );

    if (!attachment) {
      throw new NotFoundException('Attachment not found');
    }

    return attachment;
  }

  /**
   * Generate signed download URL for an attachment
   */
  async getDownloadUrl(accountId: string, attachmentId: string) {
    const attachment = await this.attachmentsRepository.findByAccountId(
      accountId,
      attachmentId,
    );

    if (!attachment) {
      throw new NotFoundException('Attachment not found');
    }

    if (attachment.status !== 'ready') {
      throw new ForbiddenException('Attachment is not available for download');
    }

    if (attachment.deletedAt) {
      throw new NotFoundException('Attachment has been deleted');
    }

    // Generate signed download URL (short TTL: 1 minute)
    const signedUrl = await this.storageService.createSignedDownloadUrl(
      attachment.storageKey,
      60,
    );

    return {
      attachmentId: attachment.id,
      filename: attachment.filename,
      contentType: attachment.contentType,
      sizeBytes: attachment.sizeBytes,
      downloadUrl: signedUrl.url,
      expiresAt: signedUrl.expiresAt,
    };
  }

  /**
   * Get all attachments for a message
   */
  async getMessageAttachments(accountId: string, messageId: string) {
    // TODO: Add message ownership check via MessagesRepository
    const attachments =
      await this.attachmentsRepository.findReadyByMessageId(messageId);

    return attachments;
  }

  /**
   * Soft delete an attachment
   */
  async deleteAttachment(accountId: string, attachmentId: string) {
    const attachment = await this.attachmentsRepository.findByAccountId(
      accountId,
      attachmentId,
    );

    if (!attachment) {
      throw new NotFoundException('Attachment not found');
    }

    if (attachment.deletedAt) {
      // Already deleted, idempotent
      return { success: true };
    }

    await this.attachmentsRepository.softDelete(attachmentId);

    this.logger.log(`Soft deleted attachment ${attachmentId}`);

    return { success: true };
  }

  /**
   * Cleanup stale pending attachments (for cron jobs)
   * Marks them as failed and removes from storage
   */
  async cleanupStalePending(olderThanMinutes: number = 60) {
    const stale =
      await this.attachmentsRepository.findStalePending(olderThanMinutes);

    for (const attachment of stale) {
      // Try to delete from storage
      await this.storageService.deleteFile(attachment.storageKey);
      // Mark as failed
      await this.attachmentsRepository.markFailed(attachment.id);
    }

    this.logger.log(`Cleaned up ${stale.length} stale pending attachments`);

    return { cleaned: stale.length };
  }

  /**
   * Permanent cleanup of soft-deleted attachments (for cron jobs)
   */
  async cleanupDeleted(olderThanMinutes: number = 1440) {
    const deleted =
      await this.attachmentsRepository.findDeletedForCleanup(olderThanMinutes);

    for (const attachment of deleted) {
      // Delete from storage
      const removed = await this.storageService.deleteFile(
        attachment.storageKey,
      );
      if (removed) {
        // Hard delete the record
        await this.attachmentsRepository.hardDelete(attachment.id);
      }
    }

    this.logger.log(`Permanently cleaned up ${deleted.length} attachments`);

    return { cleaned: deleted.length };
  }
}
